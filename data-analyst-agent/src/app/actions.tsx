"use server";

import { openai } from "@ai-sdk/openai";
import { wrapAISDKModel } from "langsmith/wrappers/vercel";
import { generateText, experimental_createMCPClient, jsonSchema, type StepResult } from "ai";
import { AgentContext } from "@/lib/types";
import { jwtDecode } from "jwt-decode";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';
import { isJWT } from "@/lib/utils";

const vercelModel = openai("gpt-4o", { structuredOutputs: true });
const modelWithTracing = wrapAISDKModel(vercelModel);

interface FormattedStep {
  step: number;
  text: string;
  tool: string;
  input: unknown;
  result: unknown;
}

interface ToolCall {
    type: string;
    toolCallId: string;
    toolName: string;
    args: {
      [key: string]: string;
    }
}

interface ToolResult {
    result: {
        content: Array<{ type: string; text: string }>;
    }
}

// Use the SDK's types directly
type AIStep = StepResult<typeof connectMcpServerTool>;

const textConfig: {[key:string]: string} = {
  "find-sellers":
    "I will use Skyfire's find-sellers tool to find a seller for the requested data & retrieve the MCP server URL of the seller",
  "create-kya-token":
    "I will use Skyfire's create-kya-token tool to create a KYA token for myself",
  "create-payment-token":
    "I will use Skyfire's create-payment-token tool to create a PAY token for the dataset which is later used by receiver to claim payment",
  "create-account-and-login":
    "I will use Dappier's create-account-and-login tool to create account and login myself using the KYA token from Skyfire and a password generated by me",
  "search-dataset":
    "I will use Dappier's search-dataset tool to find the right dataset",
  "get-pricing":
    "I will use Dappier's get-pricing tool to get the price of dataset",
  "download-dataset":
    "I will use Dappier's download-dataset tool to pay Dappier and get the download URL of the data",
  "retrieve-file-content":
    "I will use Reporting's retrieve-file-content tool to get the data and create a brief summary",
  "upload-csv":
    "I will use Reporting's upload-csv tool to upload csv data to Google Sheets and create a chart",
  "connect-mcp-server-tool": "Installing MCP server",
};

const connectMcpServerTool = {
  "connect-mcp-server-tool": {
    description: "Connects to the seller MCP server URL. After calling this tool, stop agent exection immediately after.",
    parameters: jsonSchema({
      type: "object",
      properties: {
        mcpServerUrl: {
          type: "string",
          description: "URL for seller MCP server",
        },
        sellerName: {
          type: "string",
          description: "Name of the seller",
        },
      },
      required: ["mcpServerUrl", "sellerName"],
      additionalProperties: false,
    }),
    execute: async ({ mcpServerUrl, sellerName }: { mcpServerUrl: string; sellerName: string }) => {
      return {
        content: [
          {
            type: "text",
            text: `Connecting to ${sellerName} MCP server from ${mcpServerUrl}. Stopping and restarting agent to connect to tools provided by the seller.`,
          },
        ],
      };
    },
  },
};

export async function getAgent(
  apiKey: string,
  input: string | Record<string, string>,
  agentContext: AgentContext,
) {
  console.log("apiKey", apiKey);
  if(!apiKey)
    apiKey = process.env.SKYFIRE_API_KEY || "";

  console.log("apiKey", apiKey);
  // set default agent context having SKYFIRE and VISUALIZATION MCP servers
  if (!agentContext || Object.keys(agentContext).length === 0) {
    agentContext = {
      available_mcp_servers: [
        {
          url: process.env.SKYFIRE_MCP_URL || "",
          headers: {
            "skyfire-api-key": apiKey,
          },
        },
        { url: process.env.REPORTING_MCP_URL || "", headers: {} },
      ],
      dynamically_mounted_server: [],
      conversation_history: [
        {
          role: "system",
          content:
            "You are an e-commerce buyer agent assisting user to make a purchase. When connect-mcp-server-tool tool is executed, you must stop agent execution immediately-- there should be no subsequent tools executed. Whenever there is a need to create an account, use 123456S$d#d as the password. Do no truncate or mutate tokens. Use the okta auth0 version of the service."
            // For the scope of this demo, the agent is instructed to use a static password for account creation and login. As an improvisation in future, the agent could randomly generate a password and store in agent memory and also share it with human using secure password services like 1Password, Keeper etc.
        },
      ],
    };
  }

  const inputObject: Record<string, string> =
    typeof input === "string" ? JSON.parse(input) : input;

  return runAgent(apiKey, inputObject.prompt, agentContext);
}

async function runAgent(
  apiKey: string,
  input: string,
  agentContext: AgentContext,
  initialFormattedSteps: FormattedStep[] = []
) {
  // Prepare tools from all the connected MCP servers
  // eslint-disable-next-line prefer-const
  let allTools = await prepareAllTools(agentContext);

  // add user prompt to agentContext
  agentContext.conversation_history.push({
    role: "user",
    content: input,
  });

  // Run agent by passing all the prepared tools and agentContext
  const {
    text: answer,
    usage,
    steps,
    response,
  } = await generateText({
    model: modelWithTracing,
    maxTokens: 5000,
    tools: allTools,
    maxSteps: 20,
    messages: agentContext.conversation_history,
  });

  // Update agentContext to include all the executed steps
  agentContext.conversation_history.push(...response.messages);

  // Format steps for display
  let formattedSteps: FormattedStep[] = [...initialFormattedSteps];

  formatOutput(steps, formattedSteps);

  // when MCP server is discovered, newToolsFound is set to True
  const newToolsFound = checkAndUpdateAgentContextIfMCPConnectionIsInitiated(
    steps,
    agentContext
  );

  // If new tools are discovered, RE-RUN the agent
  if (newToolsFound) {
    const modelResponse = JSON.parse(
      await runAgent(apiKey, input, agentContext, formattedSteps)
    );
    formattedSteps = modelResponse.steps;
  }

  // Return final response
  return JSON.stringify(
    {
      answer,
      steps: formattedSteps,
      usage,
      agentContext,
    },
    null,
    2
  );
}

const getDecodedJWT = (toolResult: ToolResult) => {
  const tokenRes: string = toolResult.result.content[0].text;
  const token: string = tokenRes.split(" ")[tokenRes.split(" ").length - 1];
  if (isJWT(token)) {
  const jwtHeader: string = jwtDecode(token, { header: true });
  const jwtPayload: string = jwtDecode(token);

  const jwtDecoded = { header: jwtHeader, payload: jwtPayload };
  return { token: token, jwtDecoded: jwtDecoded, isValidJWT: true };
  } 

  return { token: token, jwtDecoded: {},  isValidJWT: false };
};

const pushFormattedSteps = (formattedSteps: FormattedStep[], token: string, jwtDecoded: { header: string, payload: string}) => {
  return formattedSteps.push({
    step: 1,
    text: "Decoding JWT token...",
    tool: "thinking",
    input: {},
    result: {
      args: { token: token },
      result: { content: jwtDecoded },
    },
  });
};

const getStepDescription = (step: AIStep, toolCall: ToolCall | null) => {
  let text = step.text;
  if (toolCall) {
    text = textConfig[toolCall.toolName] || text;
    if (toolCall.toolName === "get-pricing") {
      text = text + toolCall.args["dataset_id"];
    }
  }
  return text;
};


function makeTransport(url: string, headers: Record<string, string>) {
  return new StreamableHTTPClientTransport(new URL(url), {
    requestInit: { headers },
  });
}

const prepareAllTools = async (agentContext: AgentContext) => {
  // eslint-disable-next-line
  const clients: Record<string, any> = {};

  const allServers = [
    ...agentContext?.available_mcp_servers,
    ...agentContext?.dynamically_mounted_server,
  ];
  let allTools = { ...connectMcpServerTool };

  //process mcp servers (tools + resources)
  for (let i = 0; i < allServers?.length; i++) {
    const server = allServers[i];
    const localVar = "client" + i;

    try {
      // ---- TOOLS CLIENT ----
      const toolsTransport = makeTransport(server.url, server.headers);
      const toolClient = await experimental_createMCPClient({ transport: toolsTransport });
      clients[localVar] = toolClient;

      const toolSet = await toolClient.tools();
      allTools = { ...allTools, ...toolSet };

      // ---- RESOURCES CLIENT ----
      const resourceTransport = makeTransport(server.url, server.headers);
      const mcpClient = new Client({
        name: "mcp-client",
        version: "1.0.0",
      });
      await mcpClient.connect(resourceTransport);

      const resources = await mcpClient.listResources().catch(() => null);
      if (!resources?.resources?.length) {
        console.warn(`${server.url} has no resources (skipping).`);
        continue;
      }

      for (const res of resources.resources) {
        const resource = await mcpClient.readResource({ uri: res.uri });
        console.log(
          `Resource loaded from ${server.url}:\n`,
          resource.contents[0].text
        );

        agentContext.conversation_history.push({
          role: "system",
          content: `${resource.contents[0].text}`,
        });
      }
    } catch (err) {
      console.error(`Unexpected error accessing resources for ${server.url}:`, err);
    }
  }
  return allTools;
};

const formatOutput = (steps: AIStep[], formattedSteps: FormattedStep[]) => {
  steps.forEach((step: AIStep) => {
    if (step.toolCalls.length > 0)  {
      for (let i = 0; i < step.toolCalls.length; i++) {
        const toolCall = step.toolCalls[i] as unknown as ToolCall;
        const toolResult = step.toolResults[i] as unknown as ToolResult;
        formattedSteps.push({
          step: 1,
          text: getStepDescription(step, toolCall),
          tool:
            toolCall && toolCall.toolName ? toolCall.toolName : "thinking",
          input: toolCall ? toolCall.args : {},
          result: toolResult,
        });

        if ( 
          toolCall &&
          (toolCall.toolName === "create-payment-token" ||
            toolCall.toolName === "create-kya-token" ||
            toolCall.toolName === "create-account-and-login"
            )
        ) {
          try {
          const { token, jwtDecoded, isValidJWT } = getDecodedJWT(toolResult);
          if (isValidJWT) {
          pushFormattedSteps(formattedSteps, token, JSON.parse(JSON.stringify(jwtDecoded)));
          }
          }
          catch (err){
            console.error("Error while decoding JWT token: ", err);
          }
        }

      }
    }
    else {
      formattedSteps.push({
        step: 1,
        text: getStepDescription(step, null),
        tool: "thinking",
        input: {},
        result: null,
      });
    } 
  });
};

const checkAndUpdateAgentContextIfMCPConnectionIsInitiated = (
  steps: AIStep[],
  agentContext: AgentContext
) => {
  let newToolsFound = false;

  steps.forEach((step: AIStep) => {
    const toolCall = step.toolCalls?.[0] as unknown as ToolCall;

    if (toolCall && toolCall.toolName === "connect-mcp-server-tool") {
      const url = toolCall.args["mcpServerUrl"];

       agentContext.dynamically_mounted_server = [{ url: url, headers: {} }];

      agentContext.conversation_history.push({
        role: "system",
        content:
          "You are now connected to the tools provided by the seller MCP server as well, run tools as per input prompt to solve problems step by step.",
      });

      newToolsFound = true;
      return;
    }
  });

  return newToolsFound;
};
